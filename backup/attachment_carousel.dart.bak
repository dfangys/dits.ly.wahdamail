import 'dart:io';
import 'dart:typed_data';
import 'package:enough_mail/enough_mail.dart';
import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart';
import 'package:get/get.dart';
import 'package:open_app_file/open_app_file.dart';
import 'package:path_provider/path_provider.dart';
import 'package:share_plus/share_plus.dart';
import 'package:wahda_bank/views/view/showmessage/widgets/attachment_viewer.dart';
import '../../../../services/mail_service.dart';
import '../../../../services/message_content_store.dart';
import '../../../../services/thumbnail_service.dart';
import '../../../../services/attachment_fetcher.dart';
import '../../../../utills/theme/app_theme.dart';
import '../../../../app/controllers/mailbox_controller.dart';

class AttachmentCarousel extends StatefulWidget {
  const AttachmentCarousel({
    super.key,
    required this.message,
    required this.mailbox,
    this.includeInline = false,
    this.offlineOnly = false,
    this.showHeader = true,
    this.maxDownloadBytesPerAttachment = 10 * 1024 * 1024, // 10 MB
    this.maxDownloadTotalBytes = 50 * 1024 * 1024, // 50 MB
  });
  final MimeMessage message;
  final Mailbox mailbox;
  final bool includeInline; // include inline (cid) parts in the carousel
  final bool offlineOnly; // show only cached (offline) attachments
  final bool showHeader; // show header row with actions
  final int maxDownloadBytesPerAttachment;
  final int maxDownloadTotalBytes;

  @override
  State<AttachmentCarousel> createState() => _AttachmentCarouselState();
}

class _AttachmentCarouselState extends State<AttachmentCarousel> {
  final List<_AttachmentItem> _items = [];
  bool _isLoading = true;
  bool _isBulkDownloading = false;
  // React to message meta updates (ready, attachments fetched, etc.)
  ValueNotifier<int>? _metaNotifier;
  // Enterprise-grade: small image preview fetch limit and de-dupe set
  final int _thumbPreviewMaxBytes = 1024 * 1024; // 1 MB for enterprise-grade previews
  final Set<String> _thumbFetching = <String>{};

  @override
  void initState() {
    super.initState();
    try {
      final ctrl = Get.find<MailBoxController>();
      _metaNotifier = ctrl.getMessageMetaNotifier(widget.mailbox, widget.message);
      _metaNotifier?.addListener(_loadAttachments);
    } catch (_) {}
    _loadAttachments();
  }

  @override
  void didUpdateWidget(covariant AttachmentCarousel oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.message != widget.message ||
        oldWidget.mailbox != widget.mailbox ||
        oldWidget.includeInline != widget.includeInline ||
        oldWidget.offlineOnly != widget.offlineOnly) {
      try { _metaNotifier?.removeListener(_loadAttachments); } catch (_) {}
      try {
        final ctrl = Get.find<MailBoxController>();
        _metaNotifier = ctrl.getMessageMetaNotifier(widget.mailbox, widget.message);
        _metaNotifier?.addListener(_loadAttachments);
      } catch (_) {}
      _loadAttachments();
    }
  }

Future<void> _loadAttachments() async {
    try {
      setState(() => _isLoading = true);
      _items.clear();
      final seen = <String>{};

      // Build a quick map of MIME info by (name|mime) to attach fetchId to offline items
      Map<String, String> mimeFetchByKey = {};
      List<ContentInfo> mimeCombined = const [];
      try {
        final List<ContentInfo> mimeInfosBase = widget.message.findContentInfo(disposition: ContentDisposition.attachment);
        final List<ContentInfo> inlineInfosBase = widget.includeInline
            ? widget.message.findContentInfo(disposition: ContentDisposition.inline)
            : const <ContentInfo>[];
        mimeCombined = <ContentInfo>[]..addAll(mimeInfosBase)..addAll(inlineInfosBase);
        for (final ci in mimeCombined) {
          final name = (ci.fileName ?? '').toLowerCase();
          final mime = ci.contentType?.mediaType.toString() ?? 'application/octet-stream';
          final size = ci.size ?? 0;
          final keyNM = '$name|$mime|$size';
          mimeFetchByKey.putIfAbsent(keyNM, () => ci.fetchId);
        }
      } catch (_) {}

      // On-demand metadata fetch if message only has envelope and we are allowed to show server attachments
      if (!widget.offlineOnly && mimeCombined.isEmpty) {
        try {
          final mailService = MailService.instance;
          if (!mailService.client.isConnected) {
            try { await mailService.connect().timeout(const Duration(seconds: 12)); } catch (_) {}
          }
          if (mailService.client.selectedMailbox?.encodedPath != widget.mailbox.encodedPath) {
            try { await mailService.client.selectMailbox(widget.mailbox).timeout(const Duration(seconds: 10)); } catch (_) {}
          }
          final seq = MessageSequence.fromMessage(widget.message);
          final fetched = await mailService.client
              .fetchMessageSequence(seq, fetchPreference: FetchPreference.fullWhenWithinSize)
              .timeout(const Duration(seconds: 20), onTimeout: () => <MimeMessage>[]);
          if (fetched.isNotEmpty) {
            final full = fetched.first;
            final attach = full.findContentInfo(disposition: ContentDisposition.attachment);
            final inline = widget.includeInline ? full.findContentInfo(disposition: ContentDisposition.inline) : const <ContentInfo>[];
            mimeCombined = <ContentInfo>[]..addAll(attach)..addAll(inline);
            mimeFetchByKey.clear();
            for (final ci in mimeCombined) {
              final name = (ci.fileName ?? '').toLowerCase();
              final mime = ci.contentType?.mediaType.toString() ?? 'application/octet-stream';
              final size = ci.size ?? 0;
              final keyNM = '$name|$mime|$size';
              mimeFetchByKey.putIfAbsent(keyNM, () => ci.fetchId);
            }
          }
        } catch (_) {}
      }

      // 1) Load offline cached attachments first (reliable and instant)
      try {
        if (widget.message.uid != null) {
          CachedMessageContent? cached = await MessageContentStore.instance.getContent(
            accountEmail: MailService.instance.account.email,
            mailboxPath: widget.mailbox.encodedPath.isNotEmpty ? widget.mailbox.encodedPath : widget.mailbox.path,
            uidValidity: widget.mailbox.uidValidity ?? 0,
            uid: widget.message.uid!,
          );
          // Fallback if uidValidity is unavailable after hot restart
          if (cached == null || cached.attachments.isEmpty) {
            cached = await MessageContentStore.instance.getContentAnyUidValidity(
              accountEmail: MailService.instance.account.email,
              mailboxPath: widget.mailbox.encodedPath.isNotEmpty ? widget.mailbox.encodedPath : widget.mailbox.path,
              uid: widget.message.uid!,
            );
          }
          if (cached != null && cached.attachments.isNotEmpty) {
            for (final a in cached.attachments) {
              if (!widget.includeInline && a.isInline) continue; // respect inline flag
              final nameLower = a.fileName.toLowerCase();
              final mime = a.mimeType;
              final size = a.sizeBytes;
              final keyNM = '$nameLower|$mime|$size';
              // Allow duplicates with same name/mime/size if filePath differs
              final offKey = '$keyNM|${a.filePath}';
              if (seen.add(offKey)) {
                final guessedFetch = mimeFetchByKey[keyNM];
                final identityKey = (guessedFetch != null && guessedFetch.isNotEmpty)
                    ? 'fid:$guessedFetch'
                    : 'nm:$offKey';
                _items.add(_AttachmentItem(
                  identityKey: identityKey,
                  name: a.fileName,
                  mimeType: a.mimeType,
                  size: a.sizeBytes,
                  filePath: a.filePath,
                  isImage: _looksLikeImage(a.fileName, a.mimeType),
                  fetchId: guessedFetch, // allow re-download if file missing later
                  contentId: a.contentId,
                ));
              }
            }
          }
        }
      } catch (_) {}

      // 2) Also include MIME attachments present on the message (no network fetch)
      if (!widget.offlineOnly) {
        try {
          for (final ci in mimeCombined) {
            // Use name/mime/size key for dedupe preferring offline copy
            final nameLower = (ci.fileName ?? '').toLowerCase();
            final mime = ci.contentType?.mediaType.toString() ?? 'application/octet-stream';
            final size = ci.size ?? 0;
            final keyNM = '$nameLower|$mime|$size';
            if (seen.contains(keyNM)) {
              // If an offline item exists but is missing fetchId, enrich it
              final idx = _items.indexWhere((it) => (it.name.toLowerCase() == nameLower && it.mimeType == mime && it.size == size));
              if (idx != -1 && (_items[idx].fetchId == null || _items[idx].fetchId!.isEmpty)) {
                final identityKey = 'fid:${ci.fetchId}';
                _items[idx] = _AttachmentItem(
                  identityKey: identityKey,
                  name: _items[idx].name,
                  mimeType: _items[idx].mimeType,
                  size: _items[idx].size,
                  filePath: _items[idx].filePath,
                  inlineBytes: _items[idx].inlineBytes,
                  isImage: _items[idx].isImage,
                  fetchId: ci.fetchId,
                  contentId: _items[idx].contentId,
                  isFetching: _items[idx].isFetching,
                );
              }
              continue; // skip duplicate MIME entry
            }

            // If not already seen, add MIME item
            Uint8List? bytes;
            final displayName = ci.fileName ?? 'attachment';
            final isImage = _looksLikeImage(displayName, mime);
            if (isImage && size > 0 && size <= 1024 * 1024) {
              try {
                final part = widget.message.getPart(ci.fetchId);
                if (part != null) {
                  bytes = part.decodeContentBinary();
                }
              } catch (_) {}
            }
            if (seen.add(keyNM)) {
              final identityKey = 'fid:${ci.fetchId}';
              _items.add(_AttachmentItem(
                identityKey: identityKey,
                name: displayName,
                mimeType: mime,
                size: size,
                inlineBytes: bytes,
                isImage: isImage,
                fetchId: ci.fetchId,
                contentId: null,
              ));
            }
          }
        } catch (_) {}
      }
      // Kick off non-blocking thumbnail fetch for small images without data
      _kickoffThumbnailFetch();
    } finally {
      if (mounted) setState(() => _isLoading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          if (widget.showHeader)
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 12),
              child: Row(
                children: [
                  const Icon(Icons.attach_file, size: 18),
                  const SizedBox(width: 6),
                  Text('Attachments', style: Theme.of(context).textTheme.titleSmall?.copyWith(fontWeight: FontWeight.w600)),
                  const Spacer(),
                  TextButton.icon(
                    onPressed: null,
                    icon: const Icon(Icons.download_outlined, size: 18, color: Colors.grey),
                    label: const Text('Download all', style: TextStyle(color: Colors.grey)),
                  ),
                ],
              ),
            ),
          const SizedBox(height: 6),
          SizedBox(
            height: 120,
            child: ListView.separated(
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
              scrollDirection: Axis.horizontal,
              itemCount: 3,
              separatorBuilder: (_, __) => const SizedBox(width: 8),
              itemBuilder: (context, index) => const _Pulse(width: 112, height: 112, radius: 12),
            ),
          ),
        ],
      );
    }
    if (_items.isEmpty) return const SizedBox.shrink();

    final header = !widget.showHeader
        ? const SizedBox.shrink()
        : Padding(
            padding: const EdgeInsets.symmetric(horizontal: 12),
            child: Row(
              children: [
                const Icon(Icons.attach_file, size: 18),
                const SizedBox(width: 6),
                Text('Attachments (${_items.length})', style: Theme.of(context).textTheme.titleSmall?.copyWith(fontWeight: FontWeight.w600)),
                const Spacer(),
                if (_items.length > 1)
                  TextButton.icon(
                    onPressed: _isBulkDownloading ? null : _downloadAllAttachments,
                    icon: _isBulkDownloading
                        ? const SizedBox(width: 16, height: 16, child: CircularProgressIndicator(strokeWidth: 2))
                        : const Icon(Icons.download_outlined, size: 18),
                    label: const Text('Download all'),
                  ),
              ],
            ),
          );

    return Column(
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        if (widget.showHeader) header,
        const SizedBox(height: 6),
        SizedBox(
          height: 120,
          child: ListView.separated(
            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
            scrollDirection: Axis.horizontal,
            itemCount: _items.length,
            separatorBuilder: (_, __) => const SizedBox(width: 8),
            itemBuilder: (context, index) {
              final it = _items[index];
              return _AttachmentThumb(
                item: it,
                onOpen: () => _openItem(it),
                onShare: () => _shareItem(it),
              );
            },
          ),
        ),
      ],
    );
  }

  @override
  void dispose() {
    try { _metaNotifier?.removeListener(_loadAttachments); } catch (_) {}
    _metaNotifier = null;
    super.dispose();
  }

Future<void> _openItem(_AttachmentItem it) async {
    try {
      String? path;
      // Resolve a local path, prioritizing existing file, then inline, then download
      if ((it.filePath ?? '').isNotEmpty && await File(it.filePath!).exists()) {
        path = it.filePath!;
      } else if (it.inlineBytes != null && it.inlineBytes!.isNotEmpty) {
        final tmp = await _saveTemp(it.inlineBytes!, it.name);
        path = tmp.path;
      } else {
        path = await _downloadItemIfNeeded(it);
      }

      if ((path ?? '').isEmpty) {
        _toast('Attachment data not available');
        return;
      }

      // Decide in-app viewer vs external based on mime
      final mime = it.mimeType.toLowerCase();
      final canPreviewInApp =
          mime.startsWith('image/') ||
          mime == 'application/pdf' ||
          mime.startsWith('text/') ||
          mime == 'application/json' ||
          mime.contains('csv');

      if (canPreviewInApp) {
        if (!mounted) return;
        await Get.to(() => AttachmentViewer(
              title: it.name,
              mimeType: it.mimeType,
              filePath: path!,
            ));
        return;
      }

      // Fallback to external app for complex formats (docx/xlsx/pptx, archives, etc.)
      await OpenAppFile.open(path!);
    } catch (e) {
      _toast('Unable to open: $e');
    }
  }

Future<void> _shareItem(_AttachmentItem it) async {
    try {
      if (it.filePath != null && it.filePath!.isNotEmpty) {
        try {
          final f = File(it.filePath!);
          if (await f.exists()) {
            // ignore: deprecated_member_use
            await Share.shareXFiles([XFile(it.filePath!)], text: it.name);
            return;
          }
        } catch (_) {}
        // File missing: re-download then share
        final path = await _downloadItemIfNeeded(it);
        if (path != null && path.isNotEmpty) {
          // ignore: deprecated_member_use
          await Share.shareXFiles([XFile(path)], text: it.name);
          return;
        }
      }
      if (it.inlineBytes != null && it.inlineBytes!.isNotEmpty) {
        final tmp = await _saveTemp(it.inlineBytes!, it.name);
        // ignore: deprecated_member_use
        await Share.shareXFiles([XFile(tmp.path)], text: it.name);
        return;
      }
      // On-demand fetch
      final path = await _downloadItemIfNeeded(it);
      if (path != null && path.isNotEmpty) {
        // ignore: deprecated_member_use
        await Share.shareXFiles([XFile(path)], text: it.name);
        return;
      }
      _toast('Attachment data not available to share');
    } catch (e) {
      _toast('Unable to share: $e');
    }
  }

  Future<File> _saveTemp(Uint8List data, String fileName) async {
    final dir = await getTemporaryDirectory();
    final file = File('${dir.path}/$fileName');
    await file.writeAsBytes(data, flush: true);
    return file;
  }

  void _toast(String msg) {
    final ctx = Get.context;
    if (ctx != null) {
      ScaffoldMessenger.of(ctx).showSnackBar(
        SnackBar(content: Text(msg), backgroundColor: AppTheme.infoColor),
      );
    }
  }
}

class _AttachmentItem {
  final String identityKey; // stable identity (fid:..., or nm:name|mime|size)
  final String name;
  final String mimeType;
  final int size;
  final String? filePath;
  final Uint8List? inlineBytes;
  final bool isImage;
  final String? fetchId; // for on-demand fetch when not cached
  final String? contentId; // for cid-based dedupe and reference
  final bool isFetching;
  _AttachmentItem({
    required this.identityKey,
    required this.name,
    required this.mimeType,
    required this.size,
    this.filePath,
    this.inlineBytes,
    required this.isImage,
    this.fetchId,
    this.contentId,
    this.isFetching = false,
  });
  
  Future<void> _kickoffThumbnailFetch() async {
    if (widget.offlineOnly) return;
    try {
      final items = List<_AttachmentItem>.from(_items);
      for (final it in items) {
        final isPdf = _looksLikePdf(it.mimeType, it.name);
          if (it.isImage) {
            if ((it.inlineBytes != null && it.inlineBytes!.isNotEmpty)) continue;
            if ((it.filePath ?? '').isNotEmpty) continue; // already on disk (even if invalid, errorBuilder will handle)
            final fid = it.fetchId ?? '';
            if (fid.isEmpty) continue;
            if (it.size <= 0 || it.size > _thumbPreviewMaxBytes) continue; // respect small preview policy
            if (!_thumbFetching.add(fid)) continue; // already in-flight
            final idKey = it.identityKey;
            // Fire and forget: fetch inline preview bytes for images
            () async {
              try {
                final data = await AttachmentFetcher.fetchByFetchId(
                  message: widget.message,
                  fetchId: fid,
                  mailbox: widget.mailbox,
                );
                if (data != null && data.isNotEmpty && _isLikelyRenderableImageBytes(data)) {
                  final idx = _items.indexWhere((x) => x.identityKey == idKey);
                  if (idx != -1) {
                    _items[idx] = _AttachmentItem(
                      identityKey: _items[idx].identityKey,
                      name: _items[idx].name,
                      mimeType: _items[idx].mimeType,
                      size: _items[idx].size,
                      filePath: _items[idx].filePath,
                      inlineBytes: data,
                      isImage: _items[idx].isImage,
                      fetchId: _items[idx].fetchId,
                      contentId: _items[idx].contentId,
                      isFetching: _items[idx].isFetching,
                    );
                    if (mounted) {
                      setState(() {});
                    }
                  }
                }
              } catch (_) {
                // ignore thumbnail failures
              } finally {
                _thumbFetching.remove(fid);
              }
            }();
        } else if (isPdf) {
          // For small PDFs, auto-download to enable first-page preview in tile
          if ((it.filePath ?? '').isNotEmpty) continue; // already on disk
          if (it.size <= 0 || it.size > _thumbPreviewMaxBytes) continue; // only small PDFs
          final fid = it.fetchId ?? '';
          if (fid.isEmpty) continue;
          if (!_thumbFetching.add(fid)) continue;
          () async {
            try {
              await _downloadItemIfNeeded(it); // persists to disk; UI updates accordingly
            } catch (_) {
            } finally {
              _thumbFetching.remove(fid);
            }
          }();
        } else {
          // Non-image, non-pdf: nothing to fetch for preview; placeholder tile will be shown
          continue;
        }
      }
    } catch (_) {}
  }

  bool _looksLikeImage(String name, String mime) {
    final m = (mime).toLowerCase();
    if (m.startsWith('image/')) {
      // Filter out formats Flutter typically cannot render reliably in thumbnails
      if (m.contains('heic') || m.contains('heif') || m.contains('tif')) return false;
      return true;
    }
    final ext = name.toLowerCase().split('.').last;
    const imgExt = {
      'jpg', 'jpeg', 'png', 'gif', 'webp'
    };
    return imgExt.contains(ext);
  }

  bool _looksLikePdf(String mime, String name) {
    if (mime.toLowerCase() == 'application/pdf') return true;
    return name.toLowerCase().endsWith('.pdf');
  }
}
  Future<String?> _downloadItemIfNeeded(_AttachmentItem it) async {
    try {
      if (it.filePath != null && it.filePath!.isNotEmpty) return it.filePath;
      if (it.fetchId == null || it.fetchId!.isEmpty) return null;

      // Enforce per-attachment size bound if known
      if (widget.maxDownloadBytesPerAttachment > 0 && it.size > 0 && it.size > widget.maxDownloadBytesPerAttachment) {
        _toast('Skipped ${it.name}: exceeds per-file limit');
        return null;
      }

      final mailService = MailService.instance;
      // Mark fetching
      final idxStart = _items.indexOf(it);
      if (idxStart != -1) {
        _items[idxStart] = _AttachmentItem(
          identityKey: _items[idxStart].identityKey,
          name: it.name,
          mimeType: it.mimeType,
          size: it.size,
          filePath: it.filePath,
          inlineBytes: it.inlineBytes,
          isImage: it.isImage,
          fetchId: it.fetchId,
          contentId: it.contentId,
          isFetching: true,
        );
        if (mounted) {
          setState(() {});
        }
      }
      // Ensure connection
      if (!mailService.client.isConnected) {
        try { await mailService.connect().timeout(const Duration(seconds: 12)); } catch (_) {}
      }
      // Ensure mailbox is selected
      try {
        if (mailService.client.selectedMailbox?.encodedPath != widget.mailbox.encodedPath) {
          await mailService.client.selectMailbox(widget.mailbox).timeout(const Duration(seconds: 10));
        }
      } catch (_) {}

      // Fetch the specific attachment part on demand
      final part = await mailService.client
          .fetchMessagePart(widget.message, it.fetchId!)
          .timeout(const Duration(seconds: 20));
      final encoding = part.getHeaderValue('content-transfer-encoding');
      final data = part.mimeData?.decodeBinary(encoding);
      if (data == null || data.isEmpty) return null;

      // Persist to offline store for reuse
      final path = await MessageContentStore.instance.saveAttachmentBytes(
        accountEmail: mailService.account.email,
        mailboxPath: widget.mailbox.encodedPath.isNotEmpty ? widget.mailbox.encodedPath : widget.mailbox.path,
        uidValidity: widget.mailbox.uidValidity ?? 0,
        uid: widget.message.uid ?? -1,
        fileName: it.name,
        bytes: data,
        uniquePartId: it.fetchId,
        contentId: it.contentId,
        mimeType: it.mimeType,
        size: it.size > 0 ? it.size : data.length,
      );

      // Best-effort: upsert into attachments list in DB so offline server can serve it later
      try {
        final store = MessageContentStore.instance;
        final cached = await store.getContent(
          accountEmail: mailService.account.email,
          mailboxPath: widget.mailbox.encodedPath.isNotEmpty ? widget.mailbox.encodedPath : widget.mailbox.path,
          uidValidity: widget.mailbox.uidValidity ?? 0,
          uid: widget.message.uid ?? -1,
        );
        final atts = <CachedAttachment>[];
        if (cached != null) {
          // Preserve existing attachments, avoiding duplicates
          final seen = <String>{};
          for (final a in cached.attachments) {
            final cid = (a.contentId ?? '').trim().toLowerCase();
            final fk = '${a.fileName}|${a.sizeBytes}|${a.mimeType}'.toLowerCase();
            final k = cid.isNotEmpty ? 'cid:$cid' : fk;
            if (seen.add(k)) atts.add(a);
          }
        }
        final newCid = (it.contentId ?? '').trim().toLowerCase();
        final newFk = '${it.name}|${it.size}|${it.mimeType}'.toLowerCase();
        final newKey = newCid.isNotEmpty ? 'cid:$newCid' : newFk;
        final exists = atts.any((a) {
          final cid = (a.contentId ?? '').trim().toLowerCase();
          final fk = '${a.fileName}|${a.sizeBytes}|${a.mimeType}'.toLowerCase();
          final k = cid.isNotEmpty ? 'cid:$cid' : fk;
          return k == newKey;
        });
        if (!exists) {
          atts.add(CachedAttachment(
            contentId: it.contentId,
            fileName: it.name,
            mimeType: it.mimeType,
            sizeBytes: it.size > 0 ? it.size : data.length,
            isInline: widget.includeInline, // best-effort
            filePath: path,
          ));
        }
        await store.upsertContent(
          accountEmail: mailService.account.email,
          mailboxPath: widget.mailbox.encodedPath.isNotEmpty ? widget.mailbox.encodedPath : widget.mailbox.path,
          uidValidity: widget.mailbox.uidValidity ?? 0,
          uid: widget.message.uid ?? -1,
          plainText: cached?.plainText,
          htmlSanitizedBlocked: cached?.htmlSanitizedBlocked,
          htmlFilePath: cached?.htmlFilePath,
          sanitizedVersion: cached?.sanitizedVersion ?? 2,
          attachments: atts,
        );
        // Notify other listeners (e.g., other instances) to refresh
        try { Get.find<MailBoxController>().bumpMessageMeta(widget.mailbox, widget.message); } catch (_) {}
      } catch (_) {}

      // Update UI in-place
      final idx = _items.indexWhere((x) => x.identityKey == it.identityKey);
      if (idx != -1) {
        _items[idx] = _AttachmentItem(
          identityKey: _items[idx].identityKey,
          name: it.name,
          mimeType: it.mimeType,
          size: it.size,
          filePath: path,
          inlineBytes: it.inlineBytes,
          isImage: _looksLikeImage(it.name, it.mimeType),
          fetchId: it.fetchId,
          contentId: it.contentId,
          isFetching: false,
        );
        if (mounted) {
          setState(() {});
        }
      }
      return path;
    } catch (e) {
      _toast('Download failed: $e');
      return null;
    } finally {
      // Ensure fetching flag cleared if we set it
      final idx = _items.indexWhere((x) => x.identityKey == it.identityKey);
      if (idx != -1) {
        _items[idx] = _AttachmentItem(
          identityKey: _items[idx].identityKey,
          name: _items[idx].name,
          mimeType: _items[idx].mimeType,
          size: _items[idx].size,
          filePath: _items[idx].filePath,
          inlineBytes: _items[idx].inlineBytes,
          isImage: _looksLikeImage(_items[idx].name, _items[idx].mimeType),
          fetchId: _items[idx].fetchId,
          contentId: _items[idx].contentId,
          isFetching: false,
        );
        if (mounted) {
          setState(() {});
        }
      }
    }
  }

  bool _looksLikeImage(String name, String mime) {
    final m = (mime).toLowerCase();
    if (m.startsWith('image/')) {
      // Filter out formats Flutter typically cannot render reliably in thumbnails
      if (m.contains('heic') || m.contains('heif') || m.contains('tif')) return false;
      return true;
    }
    final ext = name.toLowerCase().split('.').last;
    const imgExt = {
      'jpg', 'jpeg', 'png', 'gif', 'webp'
    };
    return imgExt.contains(ext);
  }

  bool _looksLikePdf(String mime, String name) {
    if (mime.toLowerCase() == 'application/pdf') return true;
    return name.toLowerCase().endsWith('.pdf');
  }

  Future<void> _downloadAllAttachments() async {
    if (_isBulkDownloading) return;
    setState(() {
      _isBulkDownloading = true;
    });
    try {
      int totalBytes = 0;
      int downloaded = 0;
      for (final it in List<_AttachmentItem>.from(_items)) {
        // Skip items already on disk
        if ((it.filePath ?? '').isNotEmpty) continue;
        // Skip if no fetch id available
        if ((it.fetchId ?? '').isEmpty) continue;
        // Per-file bound
        if (widget.maxDownloadBytesPerAttachment > 0 && it.size > 0 && it.size > widget.maxDownloadBytesPerAttachment) {
          continue;
        }
        // Total bound (use declared size if available)
        final est = it.size > 0 ? it.size : 0;
        if (widget.maxDownloadTotalBytes > 0 && est > 0 && totalBytes + est > widget.maxDownloadTotalBytes) {
          break;
        }
        final path = await _downloadItemIfNeeded(it);
        if (path != null && path.isNotEmpty) {
          downloaded++;
          if (est == 0) {
            try { totalBytes += await File(path).length(); } catch (_) {}
          } else {
            totalBytes += est;
          }
          if (widget.maxDownloadTotalBytes > 0 && totalBytes >= widget.maxDownloadTotalBytes) {
            break;
          }
        }
      }
      if (downloaded > 0) {
        _toast('Downloaded $downloaded attachment(s)');
      } else {
        _toast('No attachments downloaded (already available or over limits)');
      }
    } catch (e) {
      _toast('Download all failed: $e');
    } finally {
      if (mounted) {
        setState(() {
          _isBulkDownloading = false;
        });
      }
    }
  }
}

class _Pulse extends StatefulWidget {
  const _Pulse({required this.width, required this.height, this.radius = 8});
  final double width;
  final double height;
  final double radius;
  @override
  State<_Pulse> createState() => _PulseState();
}

class _PulseState extends State<_Pulse> with SingleTickerProviderStateMixin {
  late final AnimationController _c;
  late final Animation<double> _a;
  @override
  void initState() {
    super.initState();
    _c = AnimationController(vsync: this, duration: const Duration(milliseconds: 1200))..repeat(reverse: true);
    _a = Tween<double>(begin: 0.55, end: 1.0).animate(CurvedAnimation(parent: _c, curve: Curves.easeInOut));
  }
  @override
  void dispose() { _c.dispose(); super.dispose(); }
  @override
  Widget build(BuildContext context) {
    return FadeTransition(
      opacity: _a,
      child: Container(
        width: widget.width,
        height: widget.height,
        decoration: BoxDecoration(
          color: Colors.grey.shade300,
          borderRadius: BorderRadius.circular(widget.radius),
        ),
      ),
    );
  }
}

class _AttachmentThumb extends StatefulWidget {
  const _AttachmentThumb({required this.item, required this.onOpen, required this.onShare});
  final _AttachmentItem item;
  final VoidCallback onOpen;
  final VoidCallback onShare;

  @override
  State<_AttachmentThumb> createState() => _AttachmentThumbState();
}

class _AttachmentThumbState extends State<_AttachmentThumb> {
  String? _thumbPath;
  bool _loadingThumb = false;

  @override
  void initState() {
    super.initState();
    _maybeGenerateThumb();
  }

  @override
  void didUpdateWidget(covariant _AttachmentThumb oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.item.filePath != widget.item.filePath || oldWidget.item.mimeType != widget.item.mimeType) {
      _thumbPath = null;
      _maybeGenerateThumb();
    }
  }

  Future<void> _maybeGenerateThumb() async {
    final path = widget.item.filePath;
    if (path == null || path.isEmpty) return;
    
    // Generate thumbnails for all supported file types, not just images
    final mime = widget.item.mimeType.toLowerCase();
    final canGenerateThumb = mime.startsWith('image/') ||
                           mime == 'application/pdf' ||
                           mime.startsWith('text/') ||
                           mime.contains('json') ||
                           mime.contains('xml') ||
                           mime.contains('word') ||
                           mime.contains('excel') ||
                           mime.contains('powerpoint') ||
                           mime.contains('officedocument') ||
                           mime.contains('spreadsheet') ||
                           mime.contains('presentation');
    
    if (!canGenerateThumb) return;
    
    setState(() => _loadingThumb = true);
    try {
      final pth = await ThumbnailService.instance.getOrCreateThumbnail(
        filePath: path,
        mimeType: widget.item.mimeType,
        maxWidth: 200,
        maxHeight: 200,
      );
      if (!mounted) return;
      setState(() {
        _thumbPath = pth;
        _loadingThumb = false;
      });
    } catch (e) {
      if (kDebugMode) {
        print('AttachmentThumb: Thumbnail generation failed for ${widget.item.name}: $e');
      }
      if (!mounted) return;
      setState(() => _loadingThumb = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return InkWell(
      onTap: widget.item.isFetching ? null : widget.onOpen,
      borderRadius: BorderRadius.circular(10),
      child: Container(
        width: 112,
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: theme.dividerColor.withValues(alpha: 0.5)),
          color: theme.colorScheme.surface,
          boxShadow: [
            BoxShadow(color: theme.shadowColor.withValues(alpha: 0.08), blurRadius: 6, offset: const Offset(0, 2)),
          ],
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Expanded(
              child: ClipRRect(
                borderRadius: const BorderRadius.only(topLeft: Radius.circular(10), topRight: Radius.circular(10)),
                child: _buildThumb(),
              ),
            ),
            Padding(
              padding: const EdgeInsets.fromLTRB(6, 4, 6, 4),
              child: Row(
                children: [
                  Expanded(
                    child: Text(
                      widget.item.name,
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                      style: const TextStyle(fontSize: 11),
                    ),
                  ),
                  IconButton(
                    padding: EdgeInsets.zero,
                    constraints: const BoxConstraints(maxWidth: 24, maxHeight: 24),
                    icon: const Icon(Icons.more_vert, size: 16),
                    onPressed: widget.item.isFetching ? null : widget.onShare,
                  )
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildThumb() {
    final item = widget.item;
    Widget content;
    final placeholder = Container(
      color: Colors.grey.shade200,
      child: Center(
        child: Icon(_iconForMime(item.mimeType), size: 28, color: Colors.grey.shade600),
      ),
    );
    
    // Show loading indicator while generating thumbnails
    if (_loadingThumb) {
      content = Container(
        color: Colors.grey.shade200, 
        child: const Center(
          child: SizedBox(
            width: 16, 
            height: 16, 
            child: CircularProgressIndicator(strokeWidth: 2)
          )
        )
      );
    }
    // Show generated thumbnail if available (for any file type)
    else if (_thumbPath != null && _thumbPath!.isNotEmpty) {
      try {
        final f = File(_thumbPath!);
        if (f.existsSync()) {
          content = Image.file(
            f, 
            fit: BoxFit.cover, 
            gaplessPlayback: true, 
            errorBuilder: (ctx, err, st) => placeholder
          );
        } else {
          content = placeholder;
        }
      } catch (_) {
        content = placeholder;
      }
    }
    // For images: try to show original file or inline bytes as fallback
    else if (widget.item.isImage) {
      if (widget.item.filePath != null && widget.item.filePath!.isNotEmpty) {
        // fallback to full image (rare)
        try {
          final f = File(widget.item.filePath!);
          final exists = f.existsSync();
          final size = exists ? f.statSync().size : 0;
          if (exists && size > 0) {
            content = Image.file(f, fit: BoxFit.cover, gaplessPlayback: true, errorBuilder: (ctx, err, st) => placeholder);
          } else {
            content = placeholder;
          }
        } catch (_) {
          content = placeholder;
        }
      } else if (widget.item.inlineBytes != null && widget.item.inlineBytes!.isNotEmpty) {
        if (_isLikelyRenderableImageBytes(widget.item.inlineBytes!)) {
          content = Image.memory(widget.item.inlineBytes!, fit: BoxFit.cover, gaplessPlayback: true, errorBuilder: (ctx, err, st) => placeholder);
        } else {
          content = placeholder;
        }
      } else {
        content = placeholder;
      }
    }
    // For non-images: show placeholder
    else {
      content = placeholder;
    }
    // Overlay decorations: extension tag and offline badge
    return Stack(
      fit: StackFit.expand,
      children: [
        content,
        Positioned(
          left: 6,
          bottom: 6,
          child: Container(
            padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
            decoration: BoxDecoration(
              color: Colors.black54,
              borderRadius: BorderRadius.circular(6),
            ),
            child: Text(
              _ext(item.name).toUpperCase(),
              style: const TextStyle(color: Colors.white, fontSize: 10, fontWeight: FontWeight.w600),
            ),
          ),
        ),
        // File size badge (top-left)
        Positioned(
          left: 6,
          top: 6,
          child: Container(
            padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
            decoration: BoxDecoration(
              color: Colors.white70,
              borderRadius: BorderRadius.circular(6),
            ),
            child: Text(
              _fmtSize(item.size),
              style: const TextStyle(color: Colors.black87, fontSize: 9, fontWeight: FontWeight.w600),
            ),
          ),
        ),
        if ((item.filePath ?? '').isNotEmpty)
          Positioned(
            right: 6,
            top: 6,
            child: Container(
              decoration: BoxDecoration(color: Colors.white70, borderRadius: BorderRadius.circular(12)),
              child: const Padding(
                padding: EdgeInsets.all(2),
                child: Icon(Icons.cloud_done_rounded, size: 16, color: Colors.green),
              ),
            ),
          ),
        if (item.isFetching)
          Container(
            color: Colors.black26,
            child: const Center(
              child: SizedBox(width: 22, height: 22, child: CircularProgressIndicator(strokeWidth: 2)),
            ),
          ),
      ],
    );
  }

  String _ext(String name) {
    final idx = name.lastIndexOf('.');
    if (idx <= 0 || idx == name.length - 1) return '';
    return name.substring(idx + 1);
  }

  String _fmtSize(int bytes) {
    if (bytes <= 0) return '';
    const units = ['B', 'KB', 'MB', 'GB'];
    double v = bytes.toDouble();
    int i = 0;
    while (v >= 1024 && i < units.length - 1) { v /= 1024; i++; }
    return '${v.toStringAsFixed(v >= 100 ? 0 : v >= 10 ? 1 : 2)} ${units[i]}';
  }

  IconData _iconForMime(String mimeType) {
    if (mimeType.startsWith('image/')) return Icons.image;
    if (mimeType == 'application/pdf') return Icons.picture_as_pdf;
    if (mimeType.contains('zip') || mimeType.contains('compressed')) return Icons.archive;
    if (mimeType.contains('audio')) return Icons.audiotrack;
    if (mimeType.contains('video')) return Icons.videocam;
    if (mimeType.contains('word') || mimeType.contains('officedocument')) return Icons.description;
    if (mimeType.contains('excel') || mimeType.contains('spreadsheet')) return Icons.table_chart;
    if (mimeType.contains('presentation')) return Icons.slideshow;
    return Icons.insert_drive_file;
  }
}

// Lightweight image header sniffing for thumbnail safety
bool _isLikelyRenderableImageBytes(Uint8List bytes) {
  if (bytes.length < 12) return false;
  // JPEG
  if (bytes[0] == 0xFF && bytes[1] == 0xD8 && bytes[2] == 0xFF) return true;
  // PNG
  const pngSig = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];
  bool pngMatch = true;
  for (int i = 0; i < pngSig.length; i++) { if (bytes[i] != pngSig[i]) { pngMatch = false; break; } }
  if (pngMatch) return true;
  // GIF
  if (bytes[0] == 0x47 && bytes[1] == 0x49 && bytes[2] == 0x46 && bytes[3] == 0x38) return true;
  // WEBP: 'RIFF' .... 'WEBP'
  if (bytes[0] == 0x52 && bytes[1] == 0x49 && bytes[2] == 0x46 && bytes[3] == 0x46 &&
      bytes[8] == 0x57 && bytes[9] == 0x45 && bytes[10] == 0x42 && bytes[11] == 0x50) return true;
  return false;
}

